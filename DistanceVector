#!/usr/bin/env python3
from typing import Dict, Tuple, List
from copy import deepcopy

class Graph:
    def __init__(self):
        # mapping nodes to distance vector table
        # item is a dict mapping (destination, next hop): distance
        self.D:Dict[str, Dict[Tuple[str, str], int]] = {}
        self.edges:Dict[Tuple[str, str], int] = {}
        return
    
    def get_nodes(self) -> List[str]:
        # Returns the name of the router in the network, in alphabetical order
        nodes = self.D.keys()
        nodes = list(sorted(nodes))
        return nodes
    
    def add_node(self, name:str) -> None:
        # Add router if not exist
        if name not in self.D:
            self.D[name] = {}
        return
    
    def add_edge(self, a:str, b:str, cost:int) -> None:
        # add router if not exist
        self.add_node(a)
        self.add_node(b)
        
        # create a key
        if a > b:
            a, b = b, a
        edge = (a, b)
        
        # remove edge if cost == -1
        if cost == -1:
            if edge in self.edges:
                self.edges.pop(edge)
        else:
            self.edges[edge] = cost
        return
    
    def __init_dv(self):
        # D_x(y) = c(x, y)
        for (x, y), cost in self.edges.items():
            self.D[x][(y, y)] = cost
            self.D[y][(x, x)] = cost
        return
    
    
    def __dv_algorithm(self, Dx, Dy, next_hop:str, cost:int):
        # update the next hop of y's rotuer table
        # Dx(dest) = Dx(y) + Dy(dest)
        Dy_new = {(dest, next_hop): cost + cost1 for (dest, _), cost1 in Dy}
        
        # merge the two distance table
        for key in Dy_new:
            if key not in Dx or Dx[key] > Dy[key]:
                Dx[key] = Dy[key]
        return
    
    def __update_dv(self, D_prev):
        # D_prev is the distance table from time step t-1
        for (x, y), cost in self.edges.items():
            # update Dx distance table inplace with Dy's distance table inplace
            self.__dv_algorithm(Dx=self.D[x], Dy=D_prev[y], next_hop=y, cost=cost)
            self.__dv_algorithm(Dx=self.D[y], Dy=D_prev[x], next_hop=x, cost=cost)
        
        return

        
    
    def update(self):
        while True:
            D_prev = deepcopy(self.D)
            # Putting init_dv here ensures that when deleting an edge, 
            # the corresponding distance information can be deleted.
            self.__init_dv()
            self.__update_dv(D_prev)
            
    
    def print_route_table(self):
        pass
    
    def print_distance_table(self):
        pass


if __name__ == '__main__':
    g = Graph()
    # Read start section
    while True:
        line = input().strip()
        if line == 'START':
            break
        g.add_node(line)
    
    # Read UPDATE section
    while True:
        line = input().strip()
        if line == 'UPDATE':
            g.update()
            break
        a, b, cost = line.split()
        g.add_edge(a, b, int(cost))
    
    # Read END section
    UPDATE_is_empty = True
    while True:
        line = input().strip()
        if line == 'END':
            # check if UPDATE section is empty
            if not UPDATE_is_empty:
                g.update()
            break
        a, b, cost = line.split()
        g.add_edge(a, b, int(cost))
        UPDATE_is_empty = False
        